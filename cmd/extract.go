package cmd

import (
	"errors"
	"fmt"
	"os/exec"
	"strings"
)

// Generate wv Command
func (wvc WaveViewConfig) GetCommand(ace string) string {
	return fmt.Sprintf("%s -k -ace_no_gui %s &> wv.log", wvc.Command, ace)
}

// Generate extract command
func (t Task) GetExtractCommand() string {
	var rt []string

	// append cd command
	rt = append(rt, t.GetCdCommand())
	// append waveview command
	rt = append(rt, config.WaveView.GetCommand(t.SimulationFiles.ACEScript))

	return strings.Join(rt, " ")
}

// Run extract command with WaveView
// returns: csv file, errors
func (t Task) RunExtract() (string, error) {
	// Make AddFile
	t.SimulationFiles.AddFile.Make(t.SimulationDirectories.BaseDir)

	// Make results.xml
	if path, err := t.MakeResultsXml(); err != nil {
		return "", err
	} else {
		t.SimulationFiles.ResultsXML = path
	}

	// Make resultsMap.xml
	if path, err := t.MakeMapXml(); err != nil {
		return "", err
	} else {
		t.SimulationFiles.ResultsMapXML = path
	}

	cmdStr := t.GetExtractCommand()
	command := exec.Command("bash", "-c", cmdStr)
	out, err := command.CombinedOutput()
	if err != nil {
		logfile := PathJoin(t.SimulationDirectories.DstDir, "wv.log")
		return "", errors.New("Failed Extract: " + FU.Cat(logfile))
	} else {
		log.WithField("at", "Task.Run").Info(string(out))
	}

	return PathJoin(t.SimulationDirectories.DstDir, "store.csv"), nil
}

// Make result file from csv file which generated by WaveView
// returns: file path, error
func (t Task) MakeResultFileFromCSV(src string) (string, error) {
	dst := PathJoin(t.SimulationDirectories.ResultDir,
		fmt.Sprintf("%s-%s-Times%05d-SEED%05d.csv",
			t.Vtn.ToString(""), t.Vtp.ToString(""), t.Times, t.SEED))

	origin := strings.Split(FU.Cat(src), "\n")
	var store []string

	for _, line := range origin {
		// #で始まる行とTIME,SIGNAL行を飛ばす
		if len(line) == 0 || line[0] == '#' || line[0] == 'T' {
			continue
		}

		// 2カラム目を取り出す
		t := strings.Split(strings.Replace(line, " ", "", -1), ",")
		store = append(store, t[1])
	}

	if len(store)%3 != 0 {
		return "", errors.New("Invalid store.csv\n")
	}

	var result []string
	for i := 0; i < len(store); i += 3 {
		result = append(result, fmt.Sprintf("%s, %s, %s", store[i], store[i+1], store[i+2]))
	}

	// Join Text and Write
	FU.WriteFile(dst, strings.Join(result, "\n"))

	return dst, nil
}
