// Copyright © 2019 xztaityozx
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package cmd

import (
	"bufio"
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"os"
	"sync"

	"github.com/spf13/cobra"
	wvparser "github.com/xztaityozx/go-wvparser"
	"golang.org/x/xerrors"
)

// countCmd represents the count command
var countCmd = &cobra.Command{
	Use:     "count",
	Aliases: []string{"cnt"},
	Short:   "数え上げします",
	Long: `CSVを受け取って数え上げします


`,
	Run: func(cmd *cobra.Command, args []string) {
		ofile, _ := cmd.Flags().GetString("out")
		filter, _ := cmd.Flags().GetStringSlice("filter")
		parallel, _ := cmd.PersistentFlags().GetInt("Parallel")

		f := func(path string) int64 {
			if _, err := os.Stat(path); err != nil {
				log.WithError(err).Fatal("Failed count sub command")
			}

			csv, err := wvparser.WVParser{FilePath: path}.Parse()
			if err != nil {
				log.WithError(err).Fatal("Failed Parse")
			}

			c := wvparser.NewCounter(filter...)
			result := c.Aggregate(csv)

			return result
		}

		var box = map[string]int64{}
		var wg sync.WaitGroup
		sem := make(chan struct{}, parallel)
		for _, v := range args {
			wg.Add(1)
			go func(p string) {
				defer wg.Done()
				sem <- struct{}{}
				box[p] = f(p)
				<-sem
			}(v)
		}

		wg.Wait()

		if len(ofile) == 0 {
			for i, v := range box {
				fmt.Println(i, ": ", v)
			}
		} else {
			ioutil.WriteFile(ofile, []byte(fmt.Sprint(box)), 0644)
		}

	},
}

func init() {
	rootCmd.AddCommand(countCmd)
	countCmd.Flags().StringSlice("filter", []string{}, "フィルター")
	countCmd.Flags().StringP("out", "o", "", "出力ファイル")
}

type CountTask struct {
	Task Task
}

func (ct CountTask) Run(parent context.Context) TaskResult {
	ctx, cancel := context.WithCancel(parent)
	defer cancel()

	ch := make(chan int64)
	defer close(ch)
	ech := make(chan error)
	defer close(ech)

	// fork Task
	go func() {
		f, err := ct.CountUp()
		if err != nil {
			ech <- err
		} else {
			ch <- f
		}
	}()

	// return Result
	select {
	case <-ctx.Done():
		return TaskResult{
			Status: false,
			Task:   ct.Task,
		}
	case err := <-ech:
		log.WithField("at", "CountTask.Run").WithError(err).Error("Failed CountUp")
		return TaskResult{
			Status: false,
			Task:   ct.Task,
		}
	case rec := <-ch:
		ct.Task.Failure = rec
		return TaskResult{
			Status: true,
			Task:   ct.Task,
		}
	}
}

func (ct CountTask) String() string {
	return ""
}

func (ct CountTask) Self() Task {
	return ct.Task
}

// CountUp Aggregate failure from csv file which generated by WaveView
// returns: number of failure, error
func (ct CountTask) CountUp() (failure int64, err error) {
	resultDir := ct.Task.SimulationDirectories.ResultDir
	// Can not find resultDir
	if _, err := os.Stat(resultDir); err != nil {
		return -1, err
	}

	box := make([]bool, ct.Task.Times)

	filters := ct.Task.PlotPoint.ToFilterStrings()
	for _, v := range ct.Task.PlotPoint.Filters {
		p := PathJoin(resultDir, v.SignalName, fmt.Sprintf("SEED%05d.csv", ct.Task.SEED))
		if _, err := os.Stat(p); err != nil {
			return -1, err
		}

		csv, err := wvparser.WVParser{FilePath: p}.Parse()
		if err != nil {
			return -1, xerrors.Errorf("Failed Parse: %w", err)
		}

		res, err := wvparser.NewCounter(filters[v.SignalName]...).GetStatuses(csv)
		if err != nil {
			return -1, xerrors.Errorf("Failed GetStatuses: %w", err)
		}

		for i, v := range res {
			box[i] = box[i] && v
		}
	}

	failure = 0
	for _, v := range box {
		if v {
			failure++
		}
	}
	return
}

// Convert CSV file that generated by WaveView to one tran's record per one line
//returns: output file path, error
func ShapingCSV(p, signalName string, n int) (string, error) {
	out, err := ioutil.ReadFile(p)
	if err != nil {
		return "", err
	}

	tmpavv := PathJoin("/tmp/avv")
	FU.TryMkDir(tmpavv)
	tmp, err := ioutil.TempFile("/tmp/avv", signalName+".*.csv")
	if err != nil {
		return "", err
	}
	w := bufio.NewWriter(tmp)
	defer w.Flush()

	idx := 0
	for _, line := range bytes.Split(out, []byte("\n")) {
		if len(line) == 0 || line[0] == byte('#') || line[0] == byte('T') {
			continue
		}

		data := bytes.Split(bytes.Replace(line, []byte(" "), []byte(""), -1), []byte(","))[1]
		_, err := w.Write(data)
		if err != nil {
			return "", err
		}
		idx++
		if idx%n == 0 {
			_, err := w.WriteString("\n")
			if err != nil {
				return "", err
			}
		} else {
			_, err := w.WriteString(" ")
			if err != nil {
				return "", err
			}
		}
	}

	return tmp.Name(), nil
}
